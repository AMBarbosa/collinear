#' Pearson's R-squared of Observations vs Predictions
#'
#' @description
#' Internal function to compute the R-squared of observations versus model predictions.
#'
#'
#' @param o (required, numeric vector) Observations, values of a response variable. Default: NULL
#' @param p (required, numeric vector) Model predictions. Default: NULL
#'
#' @return numeric: Pearson R-squared
#' @export
#' @autoglobal
#' @family preference_order_tools
r2 <- function(
    o = NULL,
    p = NULL
){

  stats::cor(
    x = p,
    y = o,
    use = "complete.obs",
    method = "pearson"
  )^2

}

#' Area Under the Curve of Binomial Observations vs Probabilistic Model Predictions
#'
#' @description
#' Internal function to compute the AUC of binomial models within [preference_order()]. As it is build for speed, this function does not check the inputs.
#'
#'
#' @param o (required, binomial vector) Observations, values of a binomial response variable with unique values 0 and 1. Default: NULL
#' @param p (required, numeric vector) Continuous predictions of a binomial model in the range 0-1. Default: NULL
#'
#' @return numeric: Area Under the Curve
#' @export
#' @family preference_order_tools
#' @autoglobal
auc <- function(
    o = NULL,
    p = NULL
){

  if(is.null(o)){
    stop(
      "collinear::auc(): argument 'o' cannot be NULL.",
      call. = FALSE
    )
  }


  if(is.null(p)){
    stop(
      "collinear::auc(): argument 'p' cannot be NULL.",
      call. = FALSE
    )
  }

  #predicted values of the ones and the zeroes
  ones <- p[o == 1]
  zeros <- p[o == 0]

  #lengths of each vector
  ones.n <- length(ones)
  zeros.n <- length(zeros)

  if(sum(c(ones.n, zeros.n)) == 0){
    stop(
      "collinear::auc(): argument 'o' must be a binomial vector of 0s and 1s.",
      call. = FALSE
      )
  }

  #curve computation
  curve <- sum(
    rank(c(ones, zeros))[1:ones.n]
  ) - (ones.n * (ones.n + 1) / 2)

  #area under the curve
  curve / (zeros.n * ones.n)

}

#' @title Case Weights for Unbalanced Binomial or Categorical Responses
#' @param x (required, integer, character, or factor vector) Either a binomial response with 1s and 0s, or categorical responses as characters or factors. Default: `NULL`
#' @return numeric vector: case weights
#' @examples
#'  case_weights(
#'    x = c(0, 0, 0, 1, 1)
#'    )
#'
#'  case_weights(
#'    x = c("a", "a", "b", "b", "c")
#'    )
#' @family preference_order_tools
#' @autoglobal
#' @export
case_weights <- function(
    x = NULL
){

  if(is.null(x)){
    stop(
      "collinear::case_weights(): argument 'x' cannot be NULL.",
      call. = FALSE
    )
  }

  # weights per class
  # as inverse of the counts
  weights <- 1 / table(as.factor(x))

  # full vector of weights
  weights[as.character(x)]

}

#' Select Function to Compute Preference Order
#'
#' @description
#' Internal function to select a proper f_...() function to compute preference order depending on the types of the response variable and the predictors. The selection criteria is available as a data frame generated by [f_auto_rules()].
#'
#'
#' @inheritParams collinear
#' @return function name
#' @family preference_order_tools
#' @export
#' @autoglobal
#' @examples
#' f <- f_auto(
#'   df = vi[1:1000, ],
#'   response = "vi_numeric",
#'   predictors = vi_predictors_numeric
#'   )
f_auto <- function(
    df = NULL,
    response = NULL,
    predictors = NULL,
    quiet = FALSE
){

  if(is.null(df) || is.null(response) || is.null(predictors)) {
    return(NULL)
  }

  #data frame with heuristic
  rules <- f_auto_rules()

  response_type <- identify_response_type(
    df = df,
    response = response,
    quiet = quiet
  )

  if(response_type == "unknown"){
    stop(
      "collinear::f_auto(): response type is 'unknown', please select an f_...() function suitable for your response data.",
      call. = FALSE
    )
  }

  predictors_type <- identify_predictors_type(
    df = df,
    predictors = predictors
  )

  if(predictors_type == "unknown"){
    stop(
      "collinear::f_auto(): predictors type is 'unknown', please select an f_...() function suitable for your predictor data.",
      call. = FALSE
    )
  }

  #select function
  f_name <- rules[
    rules$response_type == response_type &
      rules$predictors_type == predictors_type,
    "name"
  ]

  if(quiet == FALSE){

    message(
      "\ncollinear::f_auto(): selected function: '",
      f_name,
      "()'."
    )

  }


  f_name

}


#' Rules to Select Default f Argument to Compute Preference Order
#'
#' @description
#' Data frame with rules used by [f_auto()] to select the function `f` to compute preference order in [preference_order()].
#'
#'
#' @return data frame
#' @family preference_order_tools
#' @export
#' @autoglobal
#' @examples
#' f_auto_rules()
f_auto_rules <- function(){

  data.frame(
    name = c(
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_pearson",
      "f_r2_rf",
      "f_r2_rf",
      "f_auc_rf",
      "f_auc_rf",
      "f_auc_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_r2_rf",
      "f_v_rf_categorical",
      "f_v",
      "f_v_rf_categorical"
    ),
    response_type = c(
      "continuous-binary",
      "continuous-binary",
      "continuous-binary",
      "continuous-low",
      "continuous-low",
      "continuous-low",
      "continuous-high",
      "continuous-high",
      "continuous-high",
      "integer-binomial",
      "integer-binomial",
      "integer-binomial",
      "integer-binary",
      "integer-binary",
      "integer-binary",
      "integer-low",
      "integer-low",
      "integer-low",
      "integer-high",
      "integer-high",
      "integer-high",
      "categorical",
      "categorical",
      "categorical"
    ),
    predictors_type = c(
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed",
      "numeric",
      "categorical",
      "mixed"
    )
  )

}
