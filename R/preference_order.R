#' Quantitative Preference Order for Multicollinearity Filtering
#'
#' @description
#' Calculates the preference order for multicollinearity filtering by assessing the strength of the association between all predictors and a response.
#'
#' Returns a data frame with the columns "predictor" and "preference". The former contains the predictors names in order, ready for the argument `preference_order` in [cor_select()], [vif_select()] and [collinear()]. The latter contains the result of the function `f` for each combination of predictor and response.
#'
#' Supports a parallelization setup via [future::plan()] and progress bars generated by the `progressr` package. See examples.
#'
#' @inheritParams collinear
#' @param f (optional: function) Function returning a numeric value representing the relationship between a given predictor in `predictors` and `response`. The available options are:
#' \itemize{
#'  \item [f_rsquared()] (default)
#'  \item [f_gam_deviance()]
#'  \item [f_rf_rsquared()]
#'  \item [f_logistic_auc_balanced()]
#'  \item [f_logistic_auc_unbalanced()]
#'  \item [f_gam_auc_balanced()]
#'  \item [f_gam_auc_unbalanced()]
#'  \item [f_rf_auc_balanced()]
#'  \item [f_rf_auc_unbalanced()]
#' }
#' @family preference_order
#' @return data frame
#' @examples
#'
#'data(
#'   vi,
#'   vi_predictors
#' )
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#' vi_predictors <- vi_predictors[1:20]
#'
#' #parallelization setup
#' future::plan(
#'   future::multisession,
#'   workers = 2 #set to parallelly::availableWorkers() - 1
#' )
#'
#' #progress bar
#' # progressr::handlers(global = TRUE)
#'
#' #computing preference order
#' #with response
#' #numeric and categorical predictors in the output
#' #as the R-squared between each predictor and the response
#' preference.order <- preference_order(
#'   df = vi,
#'   response = "vi_mean",
#'   predictors = vi_predictors,
#'   f = f_rsquared
#'   )
#'
#' preference.order
#'
#' #using it in variable selection with collinear()
#' selected.predictors <- cor_select(
#'   df = vi,
#'   response = "vi_mean", #don't forget the response!
#'   predictors = vi_predictors,
#'   preference_order = preference.order,
#'   max_cor = 0.75
#'   )
#'
#' selected.predictors
#'
#' #check their correlations
#' selected.predictors.cor <- cor_df(
#'   df = vi,
#'   response = "vi_mean",
#'   predictors = selected.predictors
#' )
#'
#' #all correlations below max_cor
#' selected.predictors.cor
#'
#' #USING A CUSTOM FUNCTION
#' #custom function to compute RMSE between a predictor and a response
#' #x is a predictor name
#' #y is a response name
#' #df is a data frame with multiple predictors and one response
#' #must return a single number, with higher number indicating higher preference
#' #notice we use "one minus RMSE" to give higher rank to variables with lower RMSE
#' f_rmse <- function(x, y, df){
#'
#'   xy <- df[, c(x, y)] |>
#'     na.omit() |>
#'     scale()
#'
#'   1 - sqrt(mean((xy[, 1] - xy[, 2])^2))
#'
#' }
#'
#' preference.order <- preference_order(
#'   df = vi,
#'   response = "vi_mean",
#'   predictors = vi_predictors,
#'   f = f_rmse
#' )
#'
#' preference.order
#'
#' #disable parallelization
#' future::plan(future::sequential)
#'
#' @autoglobal
#' @author Blas M. Benito, PhD
#' @export
preference_order <- function(
    df = NULL,
    response = NULL,
    predictors = NULL,
    f = f_rsquared,
    encoding_method = "mean"
){

  #stop if NULL
  if(is.null(response)){
    stop("Argument 'response' must be the name of a numeric variable in 'df'.")
  }

  #check input data frame
  df <- validate_df(
    df = df,
    min_rows = 30
  )

  #check response
  response <- validate_response(
    df = df,
    response = response
  )

  #check predictors
  predictors <- validate_predictors(
    df = df,
    response = response,
    predictors = predictors
  )

  #early output if only one predictor
  if(length(predictors) == 1){
    attributes(predictors) <- NULL
    return(predictors)
  }

  #target encode character predictors
  df <- target_encoding_lab(
    df = df,
    response = response,
    predictors = predictors,
    encoding_methods = encoding_method,
    replace = TRUE,
    verbose = FALSE
  )

  #get numeric predictors only
  predictors <- identify_numeric_predictors(
    df = df,
    predictors = predictors
  )

  #data frame to store results
  preference <- data.frame(
    predictor = predictors
  )

  #progress bar
  p <- progressr::progressor(
    steps = nrow(preference)
    )

  #computing preference order
  preference$preference <- future.apply::future_lapply(
    X = preference$predictor,
    FUN = function(x){

      p()

      f(
        x = x,
        y = response,
        df = df
      )

    }
  ) |>
    unlist() |>
    suppressWarnings()

  #reorder preference
  preference[
    order(
      preference$preference,
      decreasing = TRUE),
    ]

}

#' R-squared Between Two Variables
#'
#' @description
#' R-squared between a response and a predictor. Fastest option to compute preference order.
#'
#' @param x (required, character string) name of the predictor variable.
#' @param y (required, character string) name of the response variable
#' @param df (required, data frame) data frame with the columns 'x' and 'y'.
#'
#' @return numeric: R-squared
#' @examples
#'
#' data(vi)
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#'
#' f_rsquared(
#'   x = "growing_season_length", #predictor
#'   y = "vi_mean",               #response
#'   df = vi
#' )
#'
#' @autoglobal
#' @family preference_order
#' @export
f_rsquared <- function(x, y, df){

  stats::cor(
    x = df[[x]],
    y = df[[y]],
    use = "pairwise.complete.obs",
    method = "pearson"
  )^2

}

#' Explained Deviance From a GAM Model
#'
#' Computes the explained deviance of a response against a predictor via Generalized Additive Model (GAM). This option is slower than [f_rsquared()], but suitable when fitting GAMs with the results of a multicollinearity filtering.
#'
#' @inheritParams f_rsquared
#'
#' @return numeric: explained deviance
#' @examples
#'
#' data(vi)
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#'
#' #this example requires "mgcv" installed in the system
#' if(
#'   requireNamespace(
#'     package = "mgcv",
#'    quietly = TRUE
#'    )
#'  ){
#'
#'   f_gam_deviance(
#'     x = "growing_season_length", #predictor
#'     y = "vi_mean",               #response
#'     df = vi
#'   )
#'
#' }
#'
#' @autoglobal
#' @family preference_order
#' @export
f_gam_deviance <- function(x, y, df){

  if(!requireNamespace("mgcv", quietly = TRUE)){
    stop("The function 'f_gam_auc_unbalanced()' requires the package 'mgcv'.")
  }

  data <- data.frame(
    y = df[[y]],
    x = df[[x]]
  ) |>
    na.omit()

  m <- mgcv::gam(
    formula = y ~ s(x, k = 3),
    data = data
  )

  summary(m)$dev.expl

}


#' R-squared of Random Forest model
#'
#' Computes a univariate random forest model with `\link[ranger]{ranger}` and returns the R-squared on the out-of-bag data.
#'
#' `f_rf_rsquared()` and `f_rf_deviance()` are synonyms
#'
#' @inheritParams f_rsquared
#'
#' @return numeric: R-squared
#' @examples
#'
#' data(vi)
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#'
#' #this example requires "ranger" installed in the system
#' if(
#' requireNamespace(
#'   package = "ranger",
#'   quietly = TRUE
#'   )
#' ){
#'
#'   f_rf_rsquared(
#'     x = "growing_season_length", #predictor
#'     y = "vi_mean",               #response
#'     df = vi
#'   )
#'
#' }
#'
#' @autoglobal
#' @family preference_order
#' @export
f_rf_rsquared <- function(x, y, df){

  if(!requireNamespace("ranger", quietly = TRUE)){
    stop("The function 'f_rf_rsquared()' requires the package 'ranger'.")
  }

  data <- data.frame(
    y = df[[y]],
    x = df[[x]]
  ) |>
    na.omit()

  m <- ranger::ranger(
    formula = y ~ x,
    data = data,
    num.threads = 1,
    min.node.size = ceiling(nrow(data)/100),
    seed = 1
  )

  m$r.squared

}

#' @rdname f_rf_rsquared
#' @export
f_rf_deviance <- f_rf_rsquared


#' AUC of Random Forest Model for Unbalanced Binary Responses
#'
#' Computes a univariate random forest model with weighted cases via `\link[ranger]{ranger}` and returns the Area Under the Curve on the out-of-bag data.
#'
#' @inheritParams f_rsquared
#'
#' @return numeric: area under the curve
#' @examples
#'
#' data(vi)
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#'
#' #this example requires "ranger" installed in the system
#' if(
#'   requireNamespace(
#'     package = "ranger",
#'     quietly = TRUE
#'     )
#'   ){
#'
#'   f_rf_auc_unbalanced(
#'     x = "growing_season_length", #predictor
#'     y = "vi_binary",               #response
#'     df = vi
#'   )
#'
#' }
#'
#' @autoglobal
#' @family preference_order
#' @export
f_rf_auc_unbalanced <- function(x, y, df){

  if(!requireNamespace("ranger", quietly = TRUE)){
    stop("The function 'f_rf_auc_unbalanced()' requires the package 'ranger'.")
  }

  if(all(sort(unique(df[[y]])) == c(0, 1)) == FALSE){
    stop("Argument 'response' must be the name of a binary vector with unique values 0 and 1.")
  }

  data <- data.frame(
    y = df[[y]],
    x = df[[x]]
  ) |>
    na.omit()

  m <- ranger::ranger(
    formula = y ~ x,
    data = data,
    num.threads = 1,
    min.node.size = ceiling(nrow(data)/100),
    case.weights = case_weights(x = data$y),
    seed = 1
  )

  auc_score(
    observed = data$y,
    predicted = m$predictions
  )

}



#' AUC of Random Forest Model for Balanced Binary Responses
#'
#' Computes a univariate random forest model via [ranger::ranger()] and returns the Area Under the Curve on the out-of-bag data.
#'
#' @inheritParams f_rsquared
#'
#' @return numeric: area under the curve
#' @examples
#'
#' data(vi)
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#'
#' #this example requires "ranger" installed in the system
#' if(requireNamespace(package = "ranger", quietly = TRUE)){
#'
#'   f_rf_auc_balanced(
#'     x = "growing_season_length", #predictor
#'     y = "vi_binary",               #response
#'     df = vi
#'   )
#'
#' }
#'
#' @autoglobal
#' @family preference_order
#' @export
f_rf_auc_balanced <- function(x, y, df){

  if(!requireNamespace("ranger", quietly = TRUE)){
    stop("The function 'f_rf_auc_balanced()' requires the package 'ranger'")
  }

  if(all(sort(unique(df[[y]])) == c(0, 1)) == FALSE){
    stop("Argument 'response' must be the name of a binary vector with unique values 0 and 1.")
  }

  data <- data.frame(
    y = df[[y]],
    x = df[[x]]
  ) |>
    na.omit()

  m <- ranger::ranger(
    formula = y ~ x,
    data = data,
    num.threads = 1,
    min.node.size = ceiling(nrow(data)/100),
    seed = 1
  )

  auc_score(
    observed = data$y,
    predicted = m$predictions
  )

}


#' AUC of Binomial GLM with Logit Link for Balance Binary Responses
#'
#' Fits a logistic GLM model `y ~ x` when `y` is a binary response with values 0 and 1 and `x` is numeric. This function is suitable when the response variable is balanced. If the response is unbalanced, then [f_logistic_auc_unbalanced()] should provide better results.
#'
#'
#' @inheritParams f_rsquared
#'
#' @return numeric: area under the curve
#' @examples
#'
#' data(vi)
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#'
#' f_logistic_auc_balanced(
#'   x = "growing_season_length", #predictor
#'   y = "vi_binary",             #binary response
#'   df = vi
#' )
#'
#' @autoglobal
#' @family preference_order
#' @export
f_logistic_auc_balanced <- function(x, y, df){

  if(all(sort(unique(df[[y]])) == c(0, 1)) == FALSE){
    stop("Argument 'response' must be the name of a binary vector with unique values 0 and 1.")
  }

  data <- data.frame(
    y = df[[y]],
    x = df[[x]]
  ) |>
    na.omit()

  m <- stats::glm(
    formula = y ~ x,
    data = data,
    family = stats::binomial(link = "logit")
  ) |>
    suppressWarnings()

  auc_score(
    observed = data$y,
    predicted = stats::predict(m, type = "response")
  )

}


#' AUC of Binomial GLM with Logit Link for Unbalanced Binary Responses
#'
#' Fits a quasi-binomial GLM model `y ~ x` with case weights when `y` is an unbalanced binary response with values 0 and 1 and `x` is numeric. It uses the function [case_weights()] to weight 0s and 1s according to their frequency within `y`.
#'
#'
#' @inheritParams f_rsquared
#'
#' @return numeric: area under the curve
#' @examples
#'
#' data(vi)
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#'
#' f_logistic_auc_unbalanced(
#'   x = "growing_season_length", #predictor
#'   y = "vi_binary",             #binary response
#'   df = vi
#' )
#'
#' @autoglobal
#' @family preference_order
#' @export
f_logistic_auc_unbalanced <- function(x, y, df){

  if(all(sort(unique(df[[y]])) == c(0, 1)) == FALSE){
    stop("Argument 'response' must be the name of a binary vector with unique values 0 and 1.")
  }

  data <- data.frame(
    y = df[[y]],
    x = df[[x]]
  ) |>
    na.omit()

  m <- stats::glm(
    formula = y ~ x,
    data = data,
    family = stats::quasibinomial(link = "logit"),
    weights = case_weights(x = data$y)
  ) |>
    suppressWarnings()

  auc_score(
    observed = data$y,
    predicted = stats::predict(m, type = "response")
  )

}


#' AUC of Logistic GAM Model for Balanced Binary Responses
#'
#' Fits a binomial logistic Generalized Additive Model (GAM) `y ~ s(x, k = 3)` between a binary response and a numeric predictor and returns the Area Under the Curve of the observations versus the predictions.
#'
#'
#' @inheritParams f_rsquared
#'
#' @return numeric: area under the curve
#' @examples
#'
#' data(vi)
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#'
#' #this example requires "mgcv" installed
#' if(
#'   requireNamespace(
#'     package = "mgcv",
#'     quietly = TRUE
#'     )
#'  ){
#'
#'   f_gam_auc_balanced(
#'     x = "growing_season_length", #predictor
#'     y = "vi_binary",               #response
#'     df = vi
#'   )
#'
#' }
#'
#' @autoglobal
#' @family preference_order
#' @export
f_gam_auc_balanced <- function(x, y, df){

  if(!requireNamespace("mgcv", quietly = TRUE)){
    stop("the function 'f_gam_auc_balanced()' requires the package 'mgcv'.")
  }

  if(all(sort(unique(df[[y]])) == c(0, 1)) == FALSE){
    stop("Argument 'response' must be the name of a binary vector with unique values 0 and 1.")
  }

  data <- data.frame(
    y = df[[y]],
    x = df[[x]]
  ) |>
    na.omit()

  m <- mgcv::gam(
    formula = y ~ s(x, k = 3),
    data = data,
    family = stats::binomial(link = "logit")
  )

  auc_score(
    observed = data$y,
    predicted = stats::predict(m, type = "response")
  )

}


#' AUC of Logistic GAM Model for Unbalanced Binary Responses
#'
#' Fits a quasi-binomial logistic Generalized Additive Model (GAM) `y ~ s(x, k = 3)` with weighted cases between a binary response and a numeric predictor and returns the Area Under the Curve of the observations versus the predictions.
#'
#'
#' @inheritParams f_rsquared
#'
#' @return numeric: area under the curve
#' @examples
#'
#' data(vi)
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#'
#' #this example requires "mgcv" installed
#' if(
#'   requireNamespace(
#'     package = "mgcv",
#'     quietly = TRUE
#'     )
#'   ){
#'
#'   f_gam_auc_unbalanced(
#'     x = "growing_season_length", #predictor
#'     y = "vi_binary",               #response
#'     df = vi
#'   )
#'
#' }
#'
#' @autoglobal
#' @family preference_order
#' @export
f_gam_auc_unbalanced <- function(x, y, df){

  if(!requireNamespace("mgcv", quietly = TRUE)){
    stop("the function 'f_gam_auc_unbalanced()' requires the package 'mgcv'.")
  }

  if(all(sort(unique(df[[y]])) == c(0, 1)) == FALSE){
    stop("Argument 'response' must be the name of a binary vector with unique values 0 and 1.")
  }

  data <- data.frame(
    y = df[[y]],
    x = df[[x]]
  ) |>
    na.omit()

  m <- mgcv::gam(
    formula = y ~ s(x, k = 3),
    data = data,
    family = stats::quasibinomial(link = "logit"),
    weights = case_weights(x = data$y)
  )

  auc_score(
    observed = data$y,
    predicted = stats::predict(m, type = "response")
  )

}


#' @title Area Under the Receiver Operating Characteristic
#' @description Computes the AUC score of binary model predictions.
#' @param observed (required, integer) Numeric vector with observations. Valid values are 1 and 0. Must have the same length as `predicted`. Default: NULL
#' @param predicted (required, numeric) Numeric vector in the range 0-1 with binary model predictions. Must have the same length as `observed`.
#' @return numeric: area under the curve
#' @examples
#'
#'  out <- auc_score(
#'    observed = c(0, 0, 1, 1),
#'    predicted = c(0.1, 0.6, 0.4, 0.8)
#'    )
#' @autoglobal
#' @family preference_order
#' @export
auc_score <- function(
    observed = NULL,
    predicted = NULL
){

  if(is.null(observed) | is.null(predicted)){
    stop("Arguments 'observed' and 'predicted' must not be NULL.")
  }

  #check observations
  if(all(sort(unique(observed)) == c(0, 1)) == FALSE){
    stop("Argument 'observed' must be the name of a binary vector with unique values 0 and 1.")
  }

  #check predictions
  if(min(predicted) < 0 | max(predicted) > 1){
    stop("Argument 'predicted' must be the name of a binary vector with unique values 0 and 1.")
  }

  #predicted values of the ones and the zeroes
  ones <- stats::na.omit(predicted[observed == 1])
  zeros <- stats::na.omit(predicted[observed == 0])

  #lengths of each vector
  n.ones <- length(ones)
  n.zeros <- length(zeros)

  #curve computation
  curve <- sum(
    rank(c(ones, zeros))[1:n.ones]) -
    (n.ones*(n.ones+1)/2
    )

  #area under the curve
  auc <- curve / (n.zeros * n.ones)

  auc

}


#' @title Case Weights for Unbalanced Binary Response
#' @param x (required, integer vector) Binary response with 1s and 0s. Default: `NULL`
#' @return A vector with a length equal to `x` with case weights.
#' @examples
#' if(interactive()){
#'
#'  case_weights(
#'    x = c(0, 0, 0, 1, 1)
#'  )
#'
#'  }
#' @family preference_order
#' @autoglobal
#' @export
case_weights <- function(
    x = NULL
){

  if(is.null(x)){
    stop("Argument 'x' must not be NULL.")
  }

  #check that x is binary
  if(all(sort(unique(x)) == c(0, 1)) == FALSE){
    stop("Argument 'x' must be the name of a binary vector with unique values 0 and 1.")
  }

  #counting number of ones and zeros
  n <- length(x)
  n.1 <- sum(x)
  n.0 <- n - n.1

  #computing weights
  weight.1 <- 1/n.1
  weight.0 <- 1/n.0

  #vector of weights
  case.weights <- rep(NA, n)
  case.weights[x == 1] <- weight.1
  case.weights[x == 0] <- weight.0

  case.weights

}
