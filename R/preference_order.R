#' Quantitative Preference Order for Multicollinearity Filtering
#'
#' @description
#' Calculates the preference order for multicollinearity filtering by assessing the strength of the association between all predictors and a response.
#'
#' Returns a data frame with the columns "predictor" and "preference". The former contains the predictors names in order, ready for the argument `preference_order` in [cor_select()], [vif_select()] and [collinear()]. The latter contains the result of the function `f` for each combination of predictor and response.
#'
#' Supports a parallelization setup via [future::plan()] and progress bars generated by the `progressr` package. See examples.
#'
#' @inheritParams collinear
#' @param f (optional: function) Function returning a numeric value representing the relationship between a given predictor in `predictors` and `response`. The available options are:
#' \itemize{
#' TODO: update this list
#'  \item [f_rsquared()] (default)
#'  \item [f_gam_deviance()]
#'  \item [f_rf_rsquared()]
#'  \item [f_logistic_auc_balanced()]
#'  \item [f_logistic_auc_unbalanced()]
#'  \item [f_gam_auc_balanced()]
#'  \item [f_gam_auc_unbalanced()]
#'  \item [f_rf_auc_balanced()]
#'  \item [f_rf_auc_unbalanced()]
#' }
#' @family preference_order
#' @return data frame
#' @examples
#'
#'data(
#'   vi,
#'   vi_predictors
#' )
#'
#' #subset to limit example run time
#' vi <- vi[1:1000, ]
#' vi_predictors <- vi_predictors[1:20]
#'
#' #parallelization setup
#' future::plan(
#'   future::multisession,
#'   workers = 2 #set to parallelly::availableWorkers() - 1
#' )
#'
#' #progress bar
#' # progressr::handlers(global = TRUE)
#'
#' #computing preference order
#' #with response
#' #numeric and categorical predictors in the output
#' #as the R-squared between each predictor and the response
#' preference.order <- preference_order(
#'   df = vi,
#'   response = "vi_mean",
#'   predictors = vi_predictors,
#'   f = f_rsquared
#'   )
#'
#' preference.order
#'
#' #using it in variable selection with collinear()
#' selected.predictors <- cor_select(
#'   df = vi,
#'   response = "vi_mean", #don't forget the response!
#'   predictors = vi_predictors,
#'   preference_order = preference.order,
#'   max_cor = 0.75
#'   )
#'
#' selected.predictors
#'
#' #check their correlations
#' selected.predictors.cor <- cor_df(
#'   df = vi,
#'   response = "vi_mean",
#'   predictors = selected.predictors
#' )
#'
#' #all correlations below max_cor
#' selected.predictors.cor
#'
#' #USING A CUSTOM FUNCTION
#' #custom function to compute RMSE between a predictor and a response
#' #x is a predictor name
#' #y is a response name
#' #df is a data frame with multiple predictors and one response
#' #must return a single number, with higher number indicating higher preference
#' #notice we use "one minus RMSE" to give higher rank to variables with lower RMSE
#' f_rmse <- function(x, y, df){
#'
#'   xy <- df[, c(x, y)] |>
#'     na.omit() |>
#'     scale()
#'
#'   1 - sqrt(mean((xy[, 1] - xy[, 2])^2))
#'
#' }
#'
#' preference.order <- preference_order(
#'   df = vi,
#'   response = "vi_mean",
#'   predictors = vi_predictors,
#'   f = f_rmse
#' )
#'
#' preference.order
#'
#' #disable parallelization
#' future::plan(future::sequential)
#'
#' @autoglobal
#' @author Blas M. Benito, PhD
#' @export
preference_order <- function(
    df = NULL,
    response = NULL,
    predictors = NULL,
    f = f_rsquared,
    encoding_method = "mean"
){

  #stop if NULL
  if(is.null(response)){
    stop("Argument 'response' must be the name of a numeric variable in 'df'.")
  }

  #check input data frame
  df <- validate_df(
    df = df,
    min_rows = 30
  )

  #check response
  response <- validate_response(
    df = df,
    response = response
  )

  #check predictors
  predictors <- validate_predictors(
    df = df,
    response = response,
    predictors = predictors
  )

  #early output if only one predictor
  if(length(predictors) == 1){
    attributes(predictors) <- NULL
    return(predictors)
  }

  #target encode character predictors
  df <- target_encoding_lab(
    df = df,
    response = response,
    predictors = predictors,
    encoding_methods = encoding_method,
    replace = TRUE,
    verbose = FALSE
  )

  #get numeric predictors only
  predictors <- identify_numeric_predictors(
    df = df,
    predictors = predictors
  )

  #data frame to store results
  preference <- data.frame(
    predictor = predictors
  )

  #progress bar
  p <- progressr::progressor(
    steps = nrow(preference)
  )

  #computing preference order
  preference$preference <- future.apply::future_lapply(
    X = preference$predictor,
    FUN = function(x){

      p()

      df.x <- data.frame(
        y = df[[response]],
        x = df[[x]]
      ) |>
        na.omit()

      f(df = df.x)

    }
  ) |>
    unlist() |>
    suppressWarnings()

  #reorder preference
  preference[
    order(
      preference$preference,
      decreasing = TRUE),
  ]

}
