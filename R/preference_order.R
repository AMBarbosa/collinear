#' Quantitative Variable Prioritization Multicollinearity Filtering
#'
#' @description
#' This function ranks a set of variables by their association with a response to minimize loss of predictive power during multicollinearity filtering.
#'
#' Returns a data frame with the columns "predictor", with predictor names in order of preference, and "preference", the result of a function `f` computing the association between each predictor and the response. This data frame, or the column "predictor" can be used as inputs for the argument `preference_order` in [cor_select()], [vif_select()] and [collinear()].
#'
#' The `f` functions available are:
#' \itemize{
#'   \item Numeric response vs numeric predictor:
#'   \itemize{
#'    \item [f_r2_pearson()]: Pearson's R-squared.
#'    \item [f_r2_spearman()]: Spearman's R-squared.
#'    \item [f_r2_glm_gaussian()]: Pearson's R-squared of response versus the predictions of a Gaussian GLM.
#'    \item [f_r2_glm_gaussian_poly2()]: Gaussian GLM with second degree polynomial.
#'    \item [f_r2_gam_gaussian()]: GAM model fitted with [mgcv::gam()].
#'    \item [f_r2_rpart()]: Recursive Partition Tree fitted with [rpart::rpart()].
#'    \item [f_r2_rf()]: Random Forest model fitted with [ranger::ranger()].
#'   }
#'   \item Integer counts response vs. numeric predictor:
#'   \itemize{
#'     \item [f_r2_glm_poisson()]: Pearson's R-squared of a Poisson GLM.
#'     \item [f_r2_glm_poisson_poly2()]: Poisson GLM with second degree polynomial.
#'     \item [f_r2_gam_poisson()]: Poisson GAM.
#'   }
#'   \item Binomial response (1 and 0) vs. numeric predictor:
#'   \itemize{
#'     \item [f_auc_glm_binomial()]: AUC of quasibinomial GLM with weighted cases.
#'     \item [f_auc_glm_binomial_poly2()]: As above with second degree polynomial.
#'     \item [f_auc_gam_binomial()]: Quasibinomial GAM with weighted cases.
#'     \item [f_auc_rpart()]: Recursive Partition Tree with weighted cases.
#'     \item [f_auc_rf()]: Random Forest model with weighted cases.
#'   }
#'   \item Categorical response (character of factor) vs. categorical predictor:
#'   \itemize{
#'     \item [f_v()]: Cramer's V between two categorical variables.
#'   }
#'   \item Categorical response vs. categorical or numerical predictor:
#'   \itemize{
#'     \item [f_v_rf_categorical()]: Cramer's V of a Random Forest model.
#'   }
#' }
#'
#' When the argument `response` is the name of a numeric column in `df`, then [target_encoding_lab()] is used to transform any categorical variables named in `predictors` to numeric.
#'
#' This function supports a parallelization setup via [future::plan()] and progress bars generated by the `progressr` package. See examples.
#'
#' @inheritParams collinear
#' @param f (optional: function) Function to compute the association between each predictor in `predictors` and `response`. Default: `f_r2_pearson`
#' @family preference_order
#' @return data frame
#' @examples
#'
#'
#' data(
#'   vi,
#'   vi_predictors,
#'   vi_predictors_category
#' )
#'
#' #subsets to limit example run time
#' vi <- vi[1:1000, ]
#' vi_predictors <- vi_predictors[1:10]
#' vi_predictors_category <- vi_predictors_category[1:10]
#'
#' #parallelization setup
#' future::plan(
#'   future::multisession,
#'   workers = 2 #set to parallelly::availableWorkers() - 1
#' )
#'
#' #progress bar
#' # progressr::handlers(global = TRUE)
#'
#' #numeric response
#' df_preference <- preference_order(
#'   df = vi,
#'   response = "vi_numeric",
#'   predictors = vi_predictors,
#'   f = f_r2_pearson
#'   )
#'
#' df_preference
#'
#' #using it as input in collinear()
#' selection <- collinear(
#'   df = vi,
#'   response = "vi_numeric",
#'   predictors = vi_predictors,
#'   preference_order = df_preference
#' )
#'
#' selection
#'
#'
#' #count response
#' df_preference <- preference_order(
#'   df = vi,
#'   response = "vi_counts",
#'   predictors = vi_predictors,
#'   f = f_r2_glm_poisson
#' )
#'
#' df_preference
#'
#' #binomial response
#' df_preference <- preference_order(
#'   df = vi,
#'   response = "vi_binomial",
#'   predictors = vi_predictors,
#'   f = f_auc_glm_binomial
#' )
#'
#' df_preference
#'
#' #categorical response and predictors
#' df_preference <- preference_order(
#'   df = vi,
#'   response = "vi_category",
#'   predictors = vi_predictors_category,
#'   f = f_v
#' )
#'
#' df_preference
#'
#' #categorical response and categorical and numeric predictors
#' df_preference <- preference_order(
#'   df = vi,
#'   response = "vi_category",
#'   predictors = vi_predictors,
#'   f = f_v_rf_categorical
#' )
#'
#' df_preference
#'
#'
#' #disable parallelization
#' future::plan(future::sequential)
#'
#' @autoglobal
#' @author Blas M. Benito, PhD
#' @export
preference_order <- function(
    df = NULL,
    response = NULL,
    predictors = NULL,
    f = f_r2_pearson,
    encoding_method = "mean"
){

  #TODO: define behavior when response is NULL

  #TODO: define behavior when predictors is NULL

  #check input data frame
  df <- validate_df(
    df = df,
    min_rows = 30
  )

  #check response
  response <- validate_response(
    df = df,
    response = response
  )

  if(is.null(response)){
    stop("collinear::preference_order(): argument 'response' cannot be NULL.")
  }

  #check predictors
  predictors <- validate_predictors(
    df = df,
    response = response,
    predictors = predictors
  )

  #early output if only one predictor
  if(length(predictors) == 1){
    return(predictors)
  }

  #target encode character predictors
  df <- target_encoding_lab(
    df = df,
    response = response,
    predictors = predictors,
    encoding_methods = encoding_method,
    replace = TRUE,
    verbose = FALSE
  )

  #data frame to store results
  preference <- data.frame(
    predictor = predictors
  )

  #progress bar
  p <- progressr::progressor(
    steps = nrow(preference)
  )

  #computing preference order
  preference$preference <- future.apply::future_lapply(
    X = preference$predictor,
    FUN = function(x){

      # p()

      f(
        df = data.frame(
          y = df[[response]],
          x = df[[x]]
        ) |>
          na.omit()
        )

    }
  ) |>
    unlist() |>
    suppressWarnings()

  #reorder preference
  preference[
    order(
      preference$preference,
      decreasing = TRUE),
  ]

}
