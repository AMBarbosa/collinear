% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collinear.R
\name{collinear}
\alias{collinear}
\title{Automated multicollinearity management}
\usage{
collinear(
  df = NULL,
  response = NULL,
  predictors = NULL,
  encoding_method = "loo",
  preference_order = NULL,
  preference_f = NULL,
  preference_warn_limit = 0.8,
  cor_method = "pearson",
  cor_max = 0.75,
  vif_max = 5,
  quiet = FALSE
)
}
\arguments{
\item{df}{(required; data frame, tibble, or sf) A data frame with numeric predictors, and optionally a numeric response and categorical predictors. Default: NULL.}

\item{response}{(optional, character string or vector) Name/s of response variable/s in \code{df}. Used in target encoding when it names a numeric variable, and in the computation of preference order if \code{preference_order = NULL}. Default: NULL.}

\item{predictors}{(optional; character vector) Names of the variables to select from \code{df}. If omitted, all numeric columns in \code{df} are used instead. If argument \code{response} is not provided, non-numeric variables are ignored. Default: NULL}

\item{encoding_method}{(optional; character string). Name of the target encoding method. One of: "loo", "mean", or "rank". If NULL, target encoding is disabled. Default: "loo"}

\item{preference_order}{(optional; character vector) Variable names in \code{predictors}. Defines a priority order, from first to last, to preserve variables during the selection process. Variables not included in this argument are ranked by their Variance Inflation Factor. See \code{\link[=preference_order]{preference_order()}}. Default: NULL}

\item{preference_f}{(optional: function) Function to compute preference order. If NULL (default), the output of \code{\link[=f_default]{f_default()}} for the given data is used:
\itemize{
\item \code{\link[=f_auc_rf]{f_auc_rf()}}: \code{response} is binomial.
\item \code{\link[=f_r2_pearson]{f_r2_pearson()}}: \code{response} and \code{predictors} are numeric.
\item \code{\link[=f_v]{f_v()}}: \code{response} and \code{predictors} are categorical.
\item \code{\link[=f_v_rf_categorical]{f_v_rf_categorical()}}: \code{response} is categorical and \code{predictors} are numeric or mixed .
\item \code{\link[=f_r2_rf]{f_r2_rf()}}: in all other cases.
}
Default: NULL}

\item{preference_warn_limit}{(optional, numeric) Preference value (R-squared, AUC, or Cramer's V) over which a warning flagging suspicious predictors is issued. Disabled if NULL. Default: 0.8}

\item{cor_method}{(optional; character string) Method used to compute pairwise correlations. Either "pearson" or "spearman". Default: "pearson".}

\item{cor_max}{(optional; numeric) Maximum correlation allowed between any pair of variables in \code{predictors}. Recommended values are between 0.5 and 0.9. Higher values return larger number of predictors with a higher multicollinearity. If NULL, the pairwise correlation analysis is disabled. Default: \code{0.75}}

\item{vif_max}{(optional, numeric) Maximum Variance Inflation Factor allowed during variable selection. Recommended values are between 2.5 and 10. Higher values return larger number of predictors with a higher multicollinearity. If NULL, the variance inflation analysis is disabled. Default: 5.}

\item{quiet}{(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE}
}
\value{
\itemize{
\item character vector if \code{response} is NULL or is a string.
\item named list if \code{response} is a character vector.
}
}
\description{
Automates multicollinearity management in data frames with numeric and non-numeric predictors by combining four methods:
\itemize{
\item \strong{Target Encoding}: When a numeric \code{response} is provided and \code{encoding_method} is not NULL, it transforms categorical predictors (classes "character" and "factor") to numeric using the response values as reference. See \code{\link[=target_encoding_lab]{target_encoding_lab()}} for further details.
\item \strong{Preference Order}: When a response of any type is provided via \code{response}, the association between the response and each predictor is computed with an appropriate function (see \code{\link[=preference_order]{preference_order()}} and \code{\link[=f_default]{f_default()}}), and all predictors are ranked from higher to lower association. This rank is used to preserve important predictors during the multicollinearity filtering.
\item \strong{Pairwise Correlation Filtering}: Automated multicollinearity filtering via pairwise correlation. Correlations between numeric and categoricals  predictors are computed by target-encoding the categorical against the predictor, and correlations between categoricals are computed via Cramer's V. See \code{\link[=cor_select]{cor_select()}}, \code{\link[=cor_df]{cor_df()}}, and \code{\link[=cramer_v]{cramer_v()}} for further details.
\item \strong{VIF filtering}: Automated algorithm to identify and remove numeric predictors that are linear combinations of other predictors. See \code{\link[=vif_select]{vif_select()}} and \code{\link[=vif_df]{vif_df()}}.
}

Accepts a parallelization setup via \code{\link[future:plan]{future::plan()}} and a progress bar via \code{\link[progressr:handlers]{progressr::handlers()}} (see examples).

Unlike all other package functions, \code{collinear()} accepts a character vector as input for the argument \code{response}. When more than one response is provided, the output is a named list, with each element named after the given response contains a character vector of filtered predictors.
}
\section{Target Encoding}{


When the argument \code{response} names a \strong{numeric response variable}, categorical predictors in \code{predictors} (or in the columns of \code{df} if \code{predictors} is NULL) are converted to numeric via \strong{target encoding} with the function \code{\link[=target_encoding_lab]{target_encoding_lab()}}. When \code{response} is NULL or names a categorical variable, target-encoding is skipped. This feature facilitates multicollinearity filtering in data frames with mixed column types.
}

\section{Preference Order}{


This feature is designed to help protect important predictors during the multicollinearity filtering. It involves the arguments \code{preference_order} and \code{f}.

The argument \code{preference_order} accepts:
\itemize{
\item: A character vector of predictor names in a custom order of preference, from first to last. This vector does not need to contain all predictor names, but only the ones relevant to the user.
\item A data frame returned by \code{\link[=preference_order]{preference_order()}}, which ranks predictors based on their association with a response variable.
\item If NULL, and \code{response} is provided, then \code{\link[=preference_order]{preference_order()}} is used internally to rank the predictors using the function \code{f}. If \code{f} is NULL as well, then \code{\link[=f_default]{f_default()}} selects a proper function based on the data properties.
}
}

\section{Variance Inflation Factors}{


The Variance Inflation Factor for a given variable \eqn{a} is computed as \eqn{1/(1-R2)}, where \eqn{R2} is the multiple R-squared of a multiple regression model fitted using \eqn{a} as response and all other predictors in the input data frame as predictors, as in  \eqn{a = b + c + ...}.

The square root of the VIF of \eqn{a} is the factor by which the confidence interval of the estimate for \eqn{a} in the linear model \eqn{y = a + b + c + ...}` is widened by multicollinearity in the model predictors.

The range of VIF values is (1, Inf]. The recommended thresholds for maximum VIF may vary depending on the source consulted, being the most common values, 2.5, 5, and 10.
}

\section{VIF-based Filtering}{


The function \code{\link[=vif_select]{vif_select()}} computes Variance Inflation Factors and removes variables iteratively, until all variables in the resulting selection have a VIF below \code{vif_max}.

If the argument \code{preference_order} is not provided, all variables are ranked from lower to higher VIF, as returned by \code{\link[=vif_df]{vif_df()}}, and the variable with the higher VIF above \code{vif_max} is removed on each iteration.

If \code{preference_order} is defined, whenever two or more variables are above \code{vif_max}, the one higher in \code{preference_order} is preserved, and the next one with a higher VIF is removed. For example, for the predictors and preference order \eqn{a} and \eqn{b}, if any of their VIFs is higher than \code{vif_max}, then \eqn{b} will be removed no matter whether its VIF is lower or higher than \eqn{a}'s VIF. If their VIF scores are lower than \code{vif_max}, then both are preserved.
}

\section{Pairwise Correlation Filtering}{


The function \code{\link[=cor_select]{cor_select()}} applies a recursive forward selection algorithm to keep predictors with a maximum Pearson correlation with all other selected predictors lower than \code{cor_max}.

If the argument \code{preference_order} is not provided, the predictors are ranked from lower to higher sum of absolute pairwise correlation with all other predictors.

If \code{preference_order} is defined, whenever two or more variables are above \code{cor_max}, the one higher in \code{preference_order} is preserved. For example, for the predictors and preference order \eqn{a} and \eqn{b}, if their correlation is higher than \code{cor_max}, then \eqn{b} will be removed and \eqn{a} preserved. If their correlation is lower than \code{cor_max}, then both are preserved.
}

\examples{
#parallelization setup
future::plan(
  future::multisession,
  workers = 3 #set to parallelly::availableCores() - 1
)

#progress bar
progressr::handlers(global = TRUE)

#subset to limit example run time
df <- vi[1:1000, ]
predictors <- vi_predictors[1:10]

#predictors has mixed types
sapply(
  X = df[, predictors, drop = FALSE],
  FUN = class
)

#without response
#--------------------------------
#  no target encoding
#  no preference order
#  all predictors filtered by correlation
#  VIF filtering not required
x <- collinear(
  df = df,
  predictors = predictors,
  cor_max = 0.75, #default
  vif_max = 5    #default
  )

x

#all correlations below cor_max
cor_df(
  df = df,
  predictors = x
)

#all vif below max vif
#ignores categoricals
vif_df(
  df = df,
  predictors = x
)


#VIF filtering only
#--------------------------------
#  no target encoding
#  no preference order
#  only numerics filtered by VIF
# x <- collinear(
#   df = df,
#   predictors = predictors,
#   cor_max = NULL
# )

#correlation filtering only
#--------------------------------
#  no target encoding
#  no preference order
#  all predictors filtered by correlation
# x <- collinear(
#   df = df,
#   predictors = predictors,
#   vif_max = NULL
# )


#with numeric response
#--------------------------------

#  target encoding
#  automated preference order
#  all predictors filtered by correlation and VIF
x <- collinear(
  df = df,
  response = "vi_numeric",
  predictors = predictors
)

#disabling target encoding
#commented because it is much slower
# x <- collinear(
#   df = df,
#   response = "vi_numeric",
#   predictors = predictors,
#   encoding_method = NULL
# )

#with custom preference order
x <- collinear(
  df = df,
  response = "vi_numeric",
  predictors = predictors,
  preference_order = c(
    "swi_mean",
    "soil_type",
    "koppen_zone"
  )
)

#with quantitative preference order
preference_df <- preference_order(
  df = df,
  response = "vi_numeric",
  predictors = predictors
)

x <- collinear(
  df = df,
  response = "vi_numeric",
  predictors = predictors,
  preference_order = preference_df
)


#with several responses
#--------------------------------
x <- collinear(
    df = df,
    response = c(
      "vi_binomial",
      "vi_numeric"
      ),
    predictors = predictors
  )

#result is a named list
x

#with binomial response
#--------------------------------

#  target encoding
#  automated preference order (different f function)
#  all predictors filtered by correlation and VIF
# x <- collinear(
#   df = df,
#   response = "vi_binomial",
#   predictors = predictors
# )



#with counts response
#--------------------------------

#  target encoding
#  automated preference order (different f function)
#  all predictors filtered by correlation and VIF
# x <- collinear(
#   df = df,
#   response = "vi_counts",
#   predictors = predictors
# )

#with categorical response
#--------------------------------

#  target encoding
#  automated preference order (different f function)
# all predictors filtered by correlation
# numeric predictors filtered by VIF
# x <- collinear(
#   df = df,
#   response = "vi_category",
#   predictors = predictors
# )


#resetting to sequential processing
future::plan(future::sequential)

}
\references{
\itemize{
\item David A. Belsley, D.A., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. John Wiley & Sons. DOI: 10.1002/0471725153.
\item Micci-Barreca, D. (2001) A Preprocessing Scheme for High-Cardinality Categorical Attributes in Classification and Prediction Problems. SIGKDD Explor. Newsl. 3, 1, 27-32. DOI: 10.1145/507533.507538
}
}
\seealso{
Other automated_multicollinearity_analysis: 
\code{\link{vif_select}()}
}
\concept{automated_multicollinearity_analysis}
