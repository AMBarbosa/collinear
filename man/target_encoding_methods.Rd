% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/target_encoding_methods.R
\name{target_encoding_mean}
\alias{target_encoding_mean}
\alias{target_encoding_rnorm}
\alias{target_encoding_rank}
\alias{target_encoding_loo}
\alias{target_encoding_noise}
\title{Target-encoding methods}
\usage{
target_encoding_mean(
  df,
  response,
  predictor,
  noise = 0,
  seed = 1,
  replace = FALSE,
  verbose = TRUE
)

target_encoding_rnorm(
  df,
  response,
  predictor,
  sd_width = 0.1,
  seed = 1,
  replace = FALSE,
  verbose = TRUE
)

target_encoding_rank(
  df,
  response,
  predictor,
  noise = 0,
  seed = 1,
  replace = FALSE,
  verbose = TRUE
)

target_encoding_loo(df, response, predictor, replace = FALSE, verbose = TRUE)

target_encoding_noise(df, predictor, noise = 0, seed = 1)
}
\arguments{
\item{df}{(required; data frame, tibble, or sf) A training data frame. Default: \code{NULL}}

\item{response}{(required; character string) Name of the response. Must be a column name of \code{df}. Default: \code{NULL}}

\item{predictor}{(required; character) Name of the categorical variable to encode.}

\item{noise}{(optional; numeric) Numeric with noise values in the range 0-1. Default: \code{0}.}

\item{seed}{(optional; integer) Random seed to facilitate reproducibility. Default: \code{1}}

\item{replace}{(optional; logical) Advanced option that changes the behavior of the function. Use only if you really know exactly what you need. If \code{TRUE}, it replaces each categorical variable with its encoded version, and returns the input data frame with the replaced variables.}

\item{verbose}{(optional; logical) If TRUE, messages and plots generated during the execution of the function are displayed. Default: \code{TRUE}}

\item{sd_width}{(optional; numeric) Numeric with multiplicator of the standard deviation of each group in the categorical variable, in the range 0.01-1. Default: \code{0.1}}
}
\value{
The input data frame with a target-encoded variable.
}
\description{
Methods to apply target-encoding to individual categorical variables. The functions implemented are:
\itemize{
\item \code{target_encoding_mean()}: Each group is identified by the mean of the response over the group cases. White noise can be added via the \code{noise} argument. Columns encoded with this function are identified by the suffix "__encoded_mean". If \code{noise} is used, then the amount of noise is also added to the suffix.
\item \code{target_encoding_rank()}: Each group is identified by the rank of the mean of the response variable over the group cases. The group with the lower mean receives the rank 1. White noise can be added via the \code{noise} argument. Columns encoded with this function are identified by the suffix "__encoded_rank". If \code{noise} is used, then the amount of noise is also added to the suffix.
\item \code{target_encoding_rnorm()}: Each case in a group receives a value coming from a normal distribution with the mean and the standard deviation of the response over the cases of the group. The argument \code{sd_width} multiplies the standard deviation to reduce the spread of the obtained values. Columns encoded with this function are identified by the suffix "__encoded_rnorm_sd_width_X", where X is the amount of \code{sd_width} used.
\item \code{target_encoding_loo()}: The suffix "loo" stands for "leave-one-out". Each case in a group is encoded as the average of the response over the other cases of the group. olumns encoded with this function are identified by the suffix "__encoded_loo".
}
}
\examples{
if(interactive()){

#target_encoding mean
data(
  vi,
  "vi_mean",
  vi_predictors
)


#Group mean
#########################################################

#transforming soil_type
vi <- target_encoding_mean(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type"
)

#the encoded variable is named soil_type__encoded_mean

#plotting it against the response
ggplot2::ggplot(data = vi) +
  ggplot2::aes(
    x = plant_richness,
    y = soil_type__encoded_mean,
    color = soil_type
  ) +
  ggplot2::geom_point()


#Group rank
#########################################################

#transforming soil_type
vi <- target_encoding_rank(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type"
)

#the encoded variable is named soil_type__encoded_rank

#plotting it against the response
ggplot2::ggplot(data = vi) +
  ggplot2::aes(
    x = plant_richness,
    y = soil_type__encoded_rank,
    color = soil_type
  ) +
  ggplot2::geom_point()


#Leave-one-out
#########################################################
#transforming soil_type
vi <- target_encoding_loo(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type"
)

#the encoded variable is named soil_type__encoded_loo

#plotting it against the response
ggplot2::ggplot(data = vi) +
  ggplot2::aes(
    x = plant_richness,
    y = soil_type__encoded_loo,
    color = soil_type
  ) +
  ggplot2::geom_point()


#rnorm
#########################################################

#transforming soil_type
vi <- target_encoding_rnorm(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type"
)

#the encoded variable is named soil_type__encoded_rnorm_sd_width_0.1

#plotting it against the response
ggplot2::ggplot(data = vi) +
  ggplot2::aes(
    x = plant_richness,
    y = soil_type__encoded_rnorm_sd_width_0.1,
    color = soil_type
  ) +
  ggplot2::geom_point()


}

}
