% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/preference_order.R
\name{preference_order}
\alias{preference_order}
\title{Quantitative Preference Order for Multicollinearity Filtering}
\usage{
preference_order(
  df = NULL,
  response = NULL,
  predictors = NULL,
  f = f_rsquared,
  encoding_method = "mean"
)
}
\arguments{
\item{df}{(required; data frame, tibble, or sf) A data frame with numeric predictors, and optionally a numeric response and categorical predictors. Default: NULL.}

\item{response}{(optional, character string) Name of a numeric (non-numerics are ignored) response variable in \code{df}, only required if there are categorical variables named in the argument \code{predictors}. Default: NULL.}

\item{predictors}{(optional; character vector) Names of the variables to select from \code{df}. If omitted, all numeric columns in \code{df} are used instead. If argument \code{response} is not provided, non-numeric variables are ignored. Default: NULL}

\item{f}{(optional: function) Function returning a numeric value representing the relationship between a given predictor in \code{predictors} and \code{response}. The available options are:
\itemize{
TODO: update this list
\item \code{\link[=f_rsquared]{f_rsquared()}} (default)
\item \code{\link[=f_gam_deviance]{f_gam_deviance()}}
\item \code{\link[=f_rf_rsquared]{f_rf_rsquared()}}
\item \code{\link[=f_logistic_auc_balanced]{f_logistic_auc_balanced()}}
\item \code{\link[=f_logistic_auc_unbalanced]{f_logistic_auc_unbalanced()}}
\item \code{\link[=f_gam_auc_balanced]{f_gam_auc_balanced()}}
\item \code{\link[=f_gam_auc_unbalanced]{f_gam_auc_unbalanced()}}
\item \code{\link[=f_rf_auc_balanced]{f_rf_auc_balanced()}}
\item \code{\link[=f_rf_auc_unbalanced]{f_rf_auc_unbalanced()}}
}}

\item{encoding_method}{(optional; character string). Name of the target encoding method to transform non-numeric variables to numeric. One of "mean", "rank", "loo", "rnorm" (see \code{\link[=target_encoding_lab]{target_encoding_lab()}} for further details). Default: "mean"}
}
\value{
data frame
}
\description{
Calculates the preference order for multicollinearity filtering by assessing the strength of the association between all predictors and a response.

Returns a data frame with the columns "predictor" and "preference". The former contains the predictors names in order, ready for the argument \code{preference_order} in \code{\link[=cor_select]{cor_select()}}, \code{\link[=vif_select]{vif_select()}} and \code{\link[=collinear]{collinear()}}. The latter contains the result of the function \code{f} for each combination of predictor and response.

Supports a parallelization setup via \code{\link[future:plan]{future::plan()}} and progress bars generated by the \code{progressr} package. See examples.
}
\examples{

data(
  vi,
  vi_predictors
)

#subset to limit example run time
vi <- vi[1:1000, ]
vi_predictors <- vi_predictors[1:20]

#parallelization setup
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableWorkers() - 1
)

#progress bar
# progressr::handlers(global = TRUE)

#computing preference order
#with response
#numeric and categorical predictors in the output
#as the R-squared between each predictor and the response
preference.order <- preference_order(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  f = f_rsquared
  )

preference.order

#using it in variable selection with collinear()
selected.predictors <- cor_select(
  df = vi,
  response = "vi_mean", #don't forget the response!
  predictors = vi_predictors,
  preference_order = preference.order,
  max_cor = 0.75
  )

selected.predictors

#check their correlations
selected.predictors.cor <- cor_df(
  df = vi,
  response = "vi_mean",
  predictors = selected.predictors
)

#all correlations below max_cor
selected.predictors.cor

#USING A CUSTOM FUNCTION
#custom function to compute RMSE between a predictor and a response
#x is a predictor name
#y is a response name
#df is a data frame with multiple predictors and one response
#must return a single number, with higher number indicating higher preference
#notice we use "one minus RMSE" to give higher rank to variables with lower RMSE
f_rmse <- function(x, y, df){

  xy <- df[, c(x, y)] |>
    na.omit() |>
    scale()

  1 - sqrt(mean((xy[, 1] - xy[, 2])^2))

}

preference.order <- preference_order(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  f = f_rmse
)

preference.order

#disable parallelization
future::plan(future::sequential)

}
\seealso{
Other preference_order: 
\code{\link{auc}()},
\code{\link{case_weights}()},
\code{\link{f_auc}},
\code{\link{f_cramerv}()},
\code{\link{f_cramerv_rf_categorical}()},
\code{\link{f_r2}},
\code{\link{f_r2_counts}}
}
\author{
Blas M. Benito, PhD
}
\concept{preference_order}
